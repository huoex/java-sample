QA001
Java中如何实现多线程

在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口。

QA002
为何要用多线程

QA003
如何开启一个线程

QA004
设计一个多线程的场景

PQ001
synchronized 

在多线程应用程序的情况中，不同的线程就有可能同时访问同一个 Account 对象，
比如说一个联合帐户的所有者在不同的 ATM 上同时进行访问。在这种情况下，
存入和支出就可能以这样的方式发生：一个事务被另一个事务覆盖。
这种情况将是灾难性的。但是，Java 编程语言提供了一种简单的机制来防止发生这种覆盖。
每个对象在运行时都有一个关联的锁。这个锁可通过为方法添加关键字 synchronized 来获得。
这样，修订过的 Account 对象（如下所示）将不会遭受像数据损坏这样的错误

Java 编程语言提供了一种简单的机制来防止发生这种覆盖
synchronized 关键字阻止并发更新一个对象

线程间发信
当线程在继续执行前需要等待一个条件时，仅有 synchronized 关键字是不够的。
虽然 synchronized 关键字阻止并发更新一个对象，但它没有实现 线程间发信 。
Object 类为此提供了三个函数：wait()、notify() 和 notifyAll()。


PQ002
调试线程化的程序
在线程化的程序中，可能发生的某些常见而讨厌的情况是死锁、活锁、内存损坏和资源耗尽。
死锁
死锁可能是多线程程序最常见的问题。当一个线程需要一个资源而另一个线程持有该资源的锁时，
就会发生死锁。这种情况通常很难检测。但是，解决方案却相当好：在所有的线程中按相同的
次序获取所有资源锁。例如，如果有四个资源 ―A、B、C 和 D ― 并且一个线程可能要获取四个
资源中任何一个资源的锁，则请确保在获取对 B 的锁之前首先获取对 A 的锁，
依此类推。如果“线程 1”希望获取对 B 和 C 的锁，而“线程 2”获取了 A、C 和 D 的锁，
则这一技术可能导致阻塞，但它永远不会在这四个锁上造成死锁。

活锁
当一个线程忙于接受新任务以致它永远没有机会完成任何任务时，就会发生活锁。
这个线程最终将超出缓冲区并导致程序崩溃。试想一个秘书需要录入一封信，
但她一直在忙于接电话，所以这封信永远不会被录入。

内存损坏
如果明智地使用 synchronized 关键字，则完全可以避免内存错误这种气死人的问题。

资源耗尽
某些系统资源是有限的，如文件描述符。多线程程序可能耗尽资源，因为每个线程都可能希望
有一个这样的资源。如果线程数相当大，或者某个资源的侯选线程数远远超过了可用的资源数，
则最好使用 资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接，
它就从池中取出一个，使用以后再将它返回池中。资源池也称为 资源库。


在 Java 编程中，所有的对象都有锁。线程可以使用 synchronized 关键字来获得锁。
在任一时刻对于给定的类的实例，方法或同步的代码块只能被一个线程执行。

对象级使用锁通常是一种比较粗糙的方法，为什么要将整个对象都上锁，而不允许其他线程短暂
地使用对象中其他同步方法来访问共享资源？

如果一个对象拥有多个资源，就不需要只为了让一个线程使用其中一部分资源，
就将所有线程都锁在外面。

在方法级上同步，不能将整个方法声明为 synchronized 关键字